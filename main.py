# Импортируем необходимые модули
 import multiprocessing  # Для параллельных вычислений
 import sys  # Для работы с аргументами командной строки
 @@ -29,19 +28,19 @@
     # Возвращаем матрицу
     return matrix
 
 # Функция для вычисления одного элемента произведения матриц
 def compute_element(args):
 # Функция для вычисления одного элемента произведения матриц и записи его в файл
 def compute_and_write_element(args):
     """
     Вычисляет значение одного элемента результирующей матрицы.
     Вычисляет значение одного элемента результирующей матрицы и записывает его в файл.
 
     Параметры:
         args (tuple): Кортеж, содержащий индекс элемента и матрицы A и B.
         args (tuple): Кортеж, содержащий индекс элемента, матрицы A и B, путь к файлу и Lock.
 
     Возвращает:
         tuple: Кортеж, содержащий индекс элемента и вычисленное значение.
         None
     """
     # Распаковываем аргументы
     index, A, B = args
     index, A, B, filename, lock = args
     i, j = index  # Индексы строки и столбца для вычисляемого элемента
     res = 0  # Инициализируем переменную для накопления суммы
     # Количество элементов для суммирования (число столбцов в A или строк в B)
 @@ -50,8 +49,13 @@
     for k in range(N):
         # Умножаем элемент из строки матрицы A на элемент из столбца матрицы B и добавляем к сумме
         res += A[i][k] * B[k][j]
     # Возвращаем индекс и вычисленное значение элемента
     return (index, res)
     # Формируем строку для записи в файл
     line = f"{i} {j} {res}\n"
     # Пишем результат в файл, обеспечивая синхронизацию с помощью Lock
     with lock:
         # Открываем файл в режиме добавления
         with open(filename, 'a') as f:
             f.write(line)
 
 # Главная функция программы
 def main():
 @@ -89,42 +93,60 @@
         for j in range(result_cols):
             indices.append((i, j))  # Добавляем кортеж индексов (i, j)
 
     # Подготавливаем аргументы для функции compute_element
     args = []  # Инициализируем список аргументов
     for index in indices:
         args.append((index, A, B))  # Добавляем кортеж (индекс, матрица A, матрица B)
 
     # Определяем количество процессов
     num_processes = 4  # Задаем заранее количество процессов, например, 4
 
     # Создаем менеджер для управления общими ресурсами
     manager = multiprocessing.Manager()
     lock = manager.Lock()  # Создаем Lock для синхронизации записи в файл
 
     # Имя промежуточного файла для записи элементов сразу после вычисления
     intermediate_file = 'intermediate_results.txt'
 
     # Перед началом вычислений очищаем (если существует) или создаем новый промежуточный файл
     open(intermediate_file, 'w').close()
 
     # Подготавливаем аргументы для функции compute_and_write_element
     args = []  # Инициализируем список аргументов
     for index in indices:
         args.append((index, A, B, intermediate_file, lock))  # Добавляем необходимые аргументы
 
     # Создаем пул процессов для параллельного выполнения
     with multiprocessing.Pool(processes=num_processes) as pool:
         # Параллельно вычисляем элементы результирующей матрицы
         results = pool.map(compute_element, args)
         # Параллельно вычисляем элементы и записываем их в файл
         pool.map(compute_and_write_element, args)
 
     # Инициализируем пустую матрицу для хранения результатов
     # После вычислений необходимо собрать результаты из промежуточного файла и сформировать итоговую матрицу
     # Инициализируем пустую матрицу нужного размера
     result_matrix = []
     for i in range(result_rows):
         # Создаем строку с нулевыми значениями
         row = [0] * result_cols
         # Добавляем строку в результирующую матрицу
         result_matrix.append(row)
 
     # Заполняем результирующую матрицу вычисленными значениями
     for result in results:
         (i, j), value = result
         result_matrix[i][j] = value  # Присваиваем значение элементу матрицы
         result_matrix.append([0] * result_cols)
 
     # Читаем данные из промежуточного файла
     with open(intermediate_file, 'r') as f:
         for line in f:
             # Убираем лишние пробелы и символы перевода строки
             line = line.strip()
             if not line:
                 continue  # Пропускаем пустые строки
             # Разбиваем строку на индексы и значение
             i_str, j_str, value_str = line.split()
             i = int(i_str)
             j = int(j_str)
             value = float(value_str)
             # Записываем значение в соответствующую позицию результирующей матрицы
             result_matrix[i][j] = value
 
     # Записываем результирующую матрицу в файл
     with open('result_matrix.txt', 'w') as f:
         for row in result_matrix:
             # Преобразуем числа в строки
             str_numbers = [str(num) for num in row]
             # Объединяем числа через пробел и добавляем перевод строки
             line = ' '.join(str_numbers) + '\n'
             # Записываем строку в файл
             f.write(line)
 
 # Проверяем, является ли данный скрипт основным (а не импортированным модулем)
 if __name__ == '__main__':
     # Запускаем основную функцию
